import numpy as npimport numpy.linalg as nplinimport matplotlib.pyplot as pltfrom matplotlib import cmfrom mpi4py import MPIimport timeitfrom numpy.polynomial.polynomial import polyfitprint('hello')comm = MPI.COMM_WORLDsize = comm.Get_size()rank = comm.Get_rank()print('rank',rank,'active!')maxIter = 1000 Re      = 220nx = 520ny = 180ly = ny-1q  = 9dv = 2cx = nx/4cy = ny/2r  = ny/9uLB     = 0.04nulb  = uLB*r/Reomega = 1/(3*nulb+0.5)vel = np.fromfunction(lambda d,x,y: (1-d)*uLB*(1+1e-4*np.sin(y/ly*2*np.pi)),(2,nx,ny))obstacle = np.fromfunction(lambda x,y: (x-cx)**2+(y-cy)**2<r**2, (nx,ny))c = np.array([(x,y) for x in [0,-1,1] for y in [0,-1,1]]) i1 = np.arange(q)[np.asarray([ci[0]<0  for ci in c])] i2 = np.arange(q)[np.asarray([ci[0]==0 for ci in c])] i3 = np.arange(q)[np.asarray([ci[0]>0  for ci in c])] noslip = [c.tolist().index((-c[i]).tolist()) for i in range(q)]t = np.array([4/9, 1/9, 1/9, 1/9, 1/36, 1/36, 1/9, 1/36, 1/36])def equilibrium(rho,u):    cu   = np.dot(c,u.transpose(1,0,2))    usqr = u[0]**2+u[1]**2    feq  = np.zeros((q,nx,ny))    for i in range(q):        feq[i,:,:] = rho*t[i] + rho*t[i]*(3*cu[i] + (9/2)*cu[i]**2 - (3/2)*usqr)    return feq# Sub-Grids of x for MPI# With ghost domains#nx_i = (nx+(size-1)*2)//(size-1) # Size of a domain that includes the overlap of the adjacent domains#while (nx_i-2)*(size-1)<nx:#    nx_i += 1#nxi = nx_i - 2 # Size of the domain exclusive of the two overlap columns#nr=nx//nxi     # number of domains#dnx = nx%nxi#if dnx > 0:#    nr += 1#nr += 1 # Processor 0 = master -- Processors 1 through (nr-1) = slaves#mx = np.zeros(size,dtype=int)#for r in range(nr):#    mx[r] = nxi#if dnx > 0:#    mx[nr-1] = dnx# Without ghost domainsnx_i = (nx)//(size-1) # Size of a domain that includes the overlap of the adjacent domainswhile (nx_i)*(size-1)<nx:    nx_i += 1nxi = nx_i # Size of the domain exclusive of the two overlap columnsnr=nx//nxi     # number of domainsdnx = nx%nxiif dnx > 0:    nr += 1nr += 1 # Processor 0 = master -- Processors 1 through (nr-1) = slavesmx = np.zeros(size,dtype=int)for r in range(nr):    mx[r] = nxiif dnx > 0:    mx[nr-1] = dnxif rank == 0:    print('size',size)# Intialize matrices that enter in the parallelisation processFIN       = np.zeros((q,nx,ny))FOUT      = np.zeros((q,nx,ny))U         = np.zeros((dv,nx,ny))fin       = np.zeros((q,nx_i,ny))feq       = np.zeros((q,nx_i,ny))fout      = np.zeros((q,nx_i,ny))obs       = np.zeros((nx_i,ny),dtype=bool)#-----------------------------------------# Functions#-----------------------------------------#----------------------------------# communication#----------------------------------def get_edges():    if nr == 2:        if rank == 1:            fin[0:q,0      ,0:ny] = fin[0:q,mx[1],0:ny]            fin[0:q,mx[1]+1,0:ny] = fin[0:q,    1,0:nz]    else:        if rank > 0 and rank < nr:            edgeR = np.zeros(ny)            edgeL = np.zeros(ny)            rr = rank+1 if rank<nr-1 else 1  #right block            rl = rank-1 if rank>1 else nr-1  #left block            for a in range(q):                comm.send(fin[a,mx[rank],0:ny],dest=rr)                comm.send(fin[a,       1,0:ny],dest=rl)                edgeR = comm.recv(source=rr)                fin[a,mx[rank]+1,0:ny] = edgeR[0:ny]                edgeL = comm.recv(source=rl)                fin[a,0,0:ny] = edgeL[0:ny]#----------------------------------# send obstacle to nodes#----------------------------------def send_obs_to_nodes():    if rank == 0:        for r in np.arange(1,size):            for x in range(mx[r]):                tmp = obstacle[(r-1)*nxi + x,0:ny]                comm.send(tmp,dest=r)    if rank > 0  and rank < nr:        for x in range(mx[rank]):            tmp = comm.recv(source=0)            # with ghost            #obs[x+1,0:ny] = tmp            # without ghost            obs[x,0:ny] = tmp#----------------------------------# send fin to master#----------------------------------def send_fin_to_master():    if rank > 0 :        comm.send(fin,dest=0)    if rank == 0:        for r in range(1,nr):            tmp = comm.recv(source=r)            x0=(r-1)*nxi            FIN[0:q,x0:x0+mx[r],0:ny] = tmp[0:q,0:mx[r],0:ny] #tmp[0:q,0:mx[r],0:ny]#----------------------------------# send u to master#----------------------------------def send_u_to_master():    if rank > 0 :        comm.send(u,dest=0)    if rank == 0:        for r in range(1,nr):            tmp = comm.recv(source=r)            x0=(r-1)*nxi            U[0:dv,x0:x0+mx[r],0:ny] = tmp[0:dv,0:mx[r],0:ny] #tmp[0:q,0:mx[r],0:ny]#----------------------------------# equilibrium function#----------------------------------def equilibrium(rho,u):    cu   = np.dot(c,u.transpose(1,0,2))    usqr = u[0]**2+u[1]**2    feq  = np.zeros((q,nx_i,ny))    for i in range(q):        feq[i,:,:] = rho*t[i] + rho*t[i]*(3*cu[i] + (9/2)*cu[i]**2 - (3/2)*usqr)    return feq#----------------------------------# compute the macroscopic moments#----------------------------------def moment(fin):    rho = sum(fin)    u   = np.dot(c.transpose(), fin.transpose((1,0,2)))/rho    return rho, u#-----------------------------------------# Main program#-----------------------------------------if rank == 0:    timelmpi = np.zeros(maxIter//100)    iterl = np.zeros(maxIter//100)    start = timeit.default_timer()# Initial conditionsif rank > 0:    vel = np.fromfunction(lambda d,x,y: (1-d)*uLB*(1.0+1e-4*np.sin(y/ly*2*np.pi)),(dv,nx_i,ny))    feq = equilibrium(1.0,vel)    fin = feq.copy()# Send obstacle on the nodessend_obs_to_nodes()#----------------------------------# Main loop#----------------------------------for Iter in range(maxIter):    if rank == nr:        fin[i1,-1,:] = fin[i1,-2,:]    if rank > 0:        rho = sum(fin)        u   = np.dot(c.transpose(), fin.transpose((1,0,2)))/rho    if rank == 1:        u[:,0,:] = vel[:,0,:]        rho[0,:] = 1/(1-u[0,0,:]) * (sum(fin[i2,0,:])+2.*sum(fin[i1,0,:]))        feq = equilibrium(rho,u)        fin[i3,0,:] = fin[i1,0,:] + feq[i3,0,:] - feq[i1,0,:]     if rank > 1:        feq = equilibrium(rho,u)            # Collision step :    if rank > 0:        fout = fin - omega * (fin - feq)        for i in range(q):            fout[i,obs] = fin[noslip[i],obs]        comm.send(fout,dest=0)    if rank == 0:        for r in range(1,nr):            tmp = comm.recv(source=r)            x0=(r-1)*nxi            FOUT[0:q,x0:x0+mx[r],0:ny] = tmp[0:q,0:mx[r],0:ny] #tmp[0:q,0:mx[r],0:ny]        # Streaming step        for i in range(q):            amat = np.roll(FOUT[i,:,:],c[i,0],axis=0)            FIN[i,:,:] = np.roll(amat,c[i,1],axis=1)        for r in np.arange(1,size):            for x in range(mx[r]):                tmp = FIN[0:q,(r-1)*nxi + x,0:ny]                comm.send(tmp,dest=r)    if rank > 0 and rank < nr:        for x in range(mx[rank]):            tmp = comm.recv(source=0)            # with ghost            #fin[0:q,x+1,0:ny] = tmp            # without ghost            fin[0:q,x,0:ny] = tmp    send_u_to_master()    if rank == 0:        RHO = sum(FIN)        stop = timeit.default_timer()        # Plots        if (Iter%100==0): #           plt.clf();#            plt.imshow(np.sqrt(U[0]**2+U[1]**2).transpose(),cmap=cm.Reds)            print('Iter = ', Iter)           # plt.savefig("vel."+str(Iter/100).zfill(4)+".png")#            plt.show()                         T = stop-start            print('T = ', T)            timelmpi[Iter//100]=T            iterl[Iter//100]=Iterif rank == 0:    print('iterl = ', iterl)    print('timelmpi = ', timelmpi)    from basic_felix_0Iter import timel    print('timel = ', timel)    # Applying a linear fit with polyfit    b, m = polyfit(iterl, timel, 1)    c, n = polyfit(iterl, timelmpi, 1)    plt.xlabel('iterations')    plt.ylabel('time (s)')    plt.plot(iterl, timelmpi, '.', label='parallelised')    plt.plot(iterl, timel, '.', label='serial')    plt.plot(iterl, b + m * iterl, '-')    plt.plot(iterl, c + n * iterl, '-')    plt.legend(bbox_to_anchor=(0.3, 0.9), loc=1, borderaxespad=0.)    plt.savefig('timevsitercomp.png', bbox_inches='tight', dpi=200)