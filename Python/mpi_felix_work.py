import numpy as npimport numpy.linalg as nplinimport matplotlib.pyplot as pltfrom matplotlib import cmfrom mpi4py import MPIimport timecomm = MPI.COMM_WORLDsize = comm.Get_size()rank = comm.Get_rank()print('rank',rank,'active!')maxIter = 1000Re      = 220nx = 520ny = 180ly = ny-1.0q  = 9dv = 2cx = nx/4cy = ny/2r  = ny/9uLB     = 0.04nulb  = uLB*r/Re;omega = 1.0 / (3.*nulb+0.5)vel = np.fromfunction(lambda d,x,y: (1-d)*uLB*(1+1e-4*np.sin(y/ly*2*np.pi)),(2,nx,ny))obstacle = np.fromfunction(lambda x,y: (x-cx)**2+(y-cy)**2<r**2, (nx,ny))c = np.array([(x,y) for x in [0,-1,1] for y in [0,-1,1]]) i1 = np.arange(q)[np.asarray([ci[0]<0  for ci in c])]i2 = np.arange(q)[np.asarray([ci[0]==0 for ci in c])] i3 = np.arange(q)[np.asarray([ci[0]>0  for ci in c])] noslip = [c.tolist().index((-c[i]).tolist()) for i in range(q)]t = np.array([4/9, 1/9, 1/9, 1/9, 1/36, 1/36, 1/9, 1/36, 1/36])def equilibrium(rho,u):    cu   = np.dot(c,u.transpose(1,0,2))    usqr = u[0]**2+u[1]**2    feq  = np.zeros((q,nx,ny))    for i in range(q):        feq[i,:,:] = rho*t[i] + rho*t[i]*(3*cu[i] + (9/2)*cu[i]**2 - (3/2)*usqr)    return feq# Sub-Grids of x for MPInx_i = (nx+(size-1)*2)//(size-1) # Size of a domain that includes the overlap of the adjacent domainswhile (nx_i-2)*(size-1)<nx:    nx_i += 1nxi = nx_i - 2 # Size of the domain exclusive of the two overlap columnsnr=nx//nxi     # number of domainsdnx = nx%nxiif dnx > 0:    nr += 1nr += 1 # Processor 0 = master -- Processors 1 through (nr-1) = slavesmx = np.zeros(size,dtype=int)for r in range(nr):    mx[r] = nxiif dnx > 0:    mx[nr-1] = dnxif rank == 0:    print('size',size)# Intialise matrices that enter in the parallelisation processFIN       = np.zeros((q,nx,ny))FOUT      = np.zeros((q,nx,ny))U         = np.zeros((dv,nx,ny))fin       = np.zeros((q,nx_i,ny))feq       = np.zeros((q,nx_i,ny))fout      = np.zeros((q,nx_i,ny))obs       = np.zeros((nx_i,ny),dtype=bool)#-----------------------------------------# Functions#-----------------------------------------# communicationdef get_edges():    if nr == 2:        if rank == 1:            fin[0:q,0      ,0:ny] = fin[0:q,mx[1],0:ny]            fin[0:q,mx[1]+1,0:ny] = fin[0:q,    1,0:nz]    else:        if rank > 0 and rank < nr:            edgeR = np.zeros(ny)            edgeL = np.zeros(ny)            rr = rank+1 if rank<nr-1 else 1  #right block            rl = rank-1 if rank>1 else nr-1  #left block            for a in range(q):                comm.send(fin[a,mx[rank],0:ny],dest=rr)                comm.send(fin[a,       1,0:ny],dest=rl)                edgeR = comm.recv(source=rr)                fin[a,mx[rank]+1,0:ny] = edgeR[0:ny]                edgeL = comm.recv(source=rl)                fin[a,0,0:ny] = edgeL[0:ny]# send obstacle to nodesdef send_obs_to_nodes():    if rank == 0:        for r in np.arange(1,size):            for x in range(mx[r]):                tmp = obstacle[(r-1)*nxi + x,0:ny]                comm.send(tmp,dest=r)    if rank > 0  and rank < nr:        for x in range(mx[rank]):            tmp = comm.recv(source=0)            obs[x+1,0:ny] = tmp# send fin to masterdef send_fin_to_master():    if rank > 0 :        comm.send(fin,dest=0)    if rank == 0:        for r in range(1,nr):            tmp = comm.recv(source=r)            x0=(r-1)*nxi            FIN[0:q,x0:x0+mx[r],0:ny] = tmp[0:q,0:mx[r],0:ny] #tmp[0:q,0:mx[r],0:ny]# send u to masterdef send_u_to_master():    if rank > 0 :        comm.send(u,dest=0)    if rank == 0:        for r in range(1,nr):            tmp = comm.recv(source=r)            x0=(r-1)*nxi            U[0:dv,x0:x0+mx[r],0:ny] = tmp[0:dv,0:mx[r],0:ny] #tmp[0:q,0:mx[r],0:ny]# equilibrium functiondef equilibrium(rho,u):    cu   = np.dot(c,u.transpose(1,0,2))    usqr = u[0]**2+u[1]**2    feq  = np.zeros((q,nx_i,ny))    for i in range(q):        feq[i,:,:] = rho*t[i] + rho*t[i]*(3*cu[i] + (9/2)*cu[i]**2 - (3/2)*usqr)    return feq# compute the macroscopic momentsdef moment(fin):    rho = sum(fin)    u   = np.dot(c.transpose(), fin.transpose((1,0,2)))/rho    return rho, u#-----------------------------------------# Main program#-----------------------------------------# Initial conditionsif rank > 0:    vel = np.fromfunction(lambda d,x,y: (1-d)*uLB*(1.0+1e-4*np.sin(y/ly*2*np.pi)),(dv,nx_i,ny))    feq = equilibrium(1.0,vel)    fin = feq.copy()# Send obstacle on the nodessend_obs_to_nodes()#----------------------------------# Main loop#----------------------------------for time in range(maxIter):    #-------------------    # Outflow condition    #-------------------    if rank == nr:        fin[i1,-1,:] = fin[i1,-2,:]    #----------------    # Step 1    #----------------    if rank > 0:        rho = sum(fin)        u   = np.dot(c.transpose(), fin.transpose((1,0,2)))/rho    #----------------    # Step 2    #----------------    # He-Zou boundary condition     if rank == 1:        u[:,0,:] = vel[:,0,:]        # BC 1        rho[0,:] = 1./(1.-u[0,0,:]) * (sum(fin[i2,0,:])+2.*sum(fin[i1,0,:]))        #Equilibrium function        feq = equilibrium(rho,u)        # BC 2        fin[i3,0,:] = fin[i1,0,:] + feq[i3,0,:] - feq[i1,0,:]    if rank > 1:        feq = equilibrium(rho,u)    #------------------------    # Step 3    #------------------------    # Collision step :    if rank > 0:        fout = fin - omega * (fin - feq)        for i in range(q):            fout[i,obs] = fin[noslip[i],obs]        comm.send(fout,dest=0)    if rank == 0:        for r in range(1,nr):            tmp = comm.recv(source=r)            x0=(r-1)*nxi            FOUT[0:q,x0:x0+mx[r],0:ny] = tmp[0:q,0:mx[r],0:ny] #tmp[0:q,0:mx[r],0:ny]        # Streaming step        for i in range(q):            amat = np.roll(FOUT[i,:,:],c[i,0],axis=0)            FIN[i,:,:] = np.roll(amat,c[i,1],axis=1)        for r in np.arange(1,size):            for x in range(mx[r]):                tmp = FIN[0:q,(r-1)*nxi + x,0:ny]                comm.send(tmp,dest=r)    if rank > 0 and rank < nr:        for x in range(mx[rank]):            tmp = comm.recv(source=0)            fin[0:q,x+1,0:ny] = tmp    send_u_to_master()    if rank == 0:        RHO = sum(FIN)        #----------------------------        # Plots        #----------------------------        if (time%100==0):            plt.clf();            plt.imshow(np.sqrt(U[0]**2+U[1]**2).transpose(),cmap=cm.Reds)            print(time)            plt.savefig("vel."+str(time/100).zfill(4)+".png")        #plt.show()